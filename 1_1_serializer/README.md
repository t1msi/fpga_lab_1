
# serializer

## task
Сериализатор на вход получает «широкие» данные — длинное слово, и отправляет по одному биту на выход.

## desc


| Имя сигнала    | Напр-е | Разрядность | Комментарий                                                                                                                                                                                                                                                                           |
| -------------- | ------ | ----------- |:------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| clk_i          | input  | 1           | Тактовый сигнал.                                                                                                                                                                                                                                                                      |
| srst_i         | input  | 1           | Синхронный сброс.                                                                                                                                                                                                                                                                     |
| data_i         | input  | 16          | Входные данные.                                                                                                                                                                                                                                                                       |
| data_mod_i     | input  | 4           | Число показывает сколько бит в входных данных валидно. К примеру, если там стоит 5, то валидны старшие 5 бит [15:11], и значит только эти пять бит будут «отправлены» дальше. Если 0 – то все биты валидны. Если mod в диапазоне от 1 до 2 включительно, то эта посылка игнорируется. |
| data_val_i     | input  | 1           | Сигнал, подтверждающий, что data_i и data_mod_i валидны, держится один такт.                                                                                                                                                                                                          |
| ser_data_o     | output | 1           | «Сериализованные» данные. Будем считать, что первым битом выходит самый старший бит из data_i.                                                                                                                                                                                        |
| ser_data_val_o | output | 1           | Подтверждает валидность ser_data_o.                                                                                                                                                                                                                                                   |
| busy_o         | output | 1           | Если 1, то это говорит о том,что модуль сериализации занят, и вышестоящий модуль не пошлет новые data_i данные в тот такт, когда висит busy_o.                                                                                                                                        |


### alg
- Переменная data_mod_i_copy в начале нужна для обработки валидности бит 0, 1 и 2, ...
- 2 блока:
    - последовательный, для контроля итератора mod_counter и бита валидности ser_data_val_o
    - комбинационный, для вывода информации во внешнюю среду
- Остановка итератора происходит за счет следующих условий: либо срабатывание reset, либо равенство итератора с кол-вом валидных бит.
- Побитовая передача начнется после инициализации mod_counter и ser_data_val_o, при условии положительного входного бита валидности data_val_i
- Обратная связь осуществляется через ser_data_val_o (сериализованные данные передаются в установленный источник) и busy_o (занятость модуля, то есть или уже читает данные с одного источника, или уже передает биты туда. Нужна чтобы несколько источников могли пользоваться модулем)

### test
В скрипте для ModelSim вызываются 2 собственные функции do_compile start_sim

В начале testbench происходит первичная инициализация, до момента когда rst_done станет равен 1.

Отправка проводится за счет генерации входных чисел data_i_var (.data_i), data_i_len (data_mod_i) в цикле. Тем самым можно покрыть все возможные наборы данных. Важно при этом использовать 2 цикла (1-й для присваивания данных на отправку, 2-й для инициализации ser_data_i_val)

Обратное принятие данных происходит в отдельном блоке за счет счетчика ser_data_counter, который определяет конец data_i_var по копии переменной data_i_len (она нужна для обработки крайних случаев длинны валидных бит 0, 1 и 2, ...)

Тестирование осуществляется за счет сравнивания полученного бита ser_data и бита отправленного, который вычисляется с помощью ser_data_counter. Для записи не прошедших тестов используется бесконечная очередь, в конец записываются "координаты" теста. В дополнение в консоль выводятся сообщения о состоянии переменных и результаты теста на каждый цикл передачи. В конце, если ошибок не обнаружено выводится сообщение "ALL TESTS PASSED", иначе по очереди будут написаны координаты плохих тестов.

## install

```
git clone https://github.com/t1msi/fpga_lab_1.git
cd fpga_lab_1/1_1_serializer/tb/
vsim&

do make.tcl
```

## ref
- https://www.youtube.com/playlist?list=PLOiK7Vmp7kf-YmjuuJKvDvmJdxKs826kx
- https://github.com/stcmtk/fpga-webinar-2020
- https://github.com/johan92/fpga-for-beginners
- https://habr.com/en/articles/281525/