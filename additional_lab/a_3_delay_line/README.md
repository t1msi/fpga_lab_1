# priority_encoder (3 bit)

## task
Модуль должен задержать data_o на data_delay_i тактов.

Считаем, что значение data_delay_i будет меняться редко. Проверять работу модуля будут только через 16 тактов после того, как сменилось значение data_delay_i.

Требуется нарисовать с помощью Block diagram/Schematic редактора в Quartus.

## desc

| Имя сигнала  | Напр-е | Разрядность | Комментарий                                                                                           |
| ------------ | ------ | ----------- | :---------------------------------------------------------------------------------------------------- |
| data_i       | input  | 1           | Входные данные.                                                                                       |
| data_delay_i | input  | 4           | Сигнал валидности входных данных. Если 0, то передача не происходит, иначе количество тактов задержки |
| data_o       | output | 1           | Сигнал data_i задержанный на data_dealy_i тактов.                                                     |


### alg
Функцию можно представить в древовидном двоичном виде

![](attachments/LUT.jpg)

- При data_delay_i = 0 передача не происходит
- Розовым помечены AND2, которые составляют LUT, для упрощения рядом с ними используются OR2 и OR3, для передачи на разряд выше. Есть рассматриваемых сценария: 0000 - все нули (не будет передачи), xx0x и xx1x (w/1) - уже присваивали data_i и передавали через сдвиговый регистр (отдельно рассматриваются случаи откуда приходит значение, то есть последний 0 или 1), 001x (new 1) - когда в первый раз будем передавать через регистры
- Оранжевым помечены AND2, которые берут значения AND2 для LUT и data_i (либо новое, либо из сдвигового регистра предыдущего разряда, либо, если несколько разрядов не передается, то из предыдущего значения для xx0x, помеченного OR зеленым). Для совмещения используется OR и помечается зеленым, после этого происходит передача в сдвиговый регистр или выше на разряд (для 0).
- Для удобства сделаны bus линии, все интерфейсные компоненты и регистры находятся сверху на схеме, а логика снизу.

### test
В скрипте для ModelSim вызываются 2 собственные функции do_compile start_sim. bdf файл схемы из quartus уже скомпилирован в verilog файл.

В начале testbench происходит первичная инициализация, до момента когда rst_done станет равен 1.

Отправка проводится за счет генерации входной последовтельности в таске gen_data и передачи в data_i (строб из 1 на 1 такт) и data_delay_i в таске send_data. Между вызовами send_data могут быть задержки (опция burst, по умолчанию).

После отправки и перед ней целого числа, происходит запись в mailbox sended_data и глобальную переменную test_data, соответственно, для сохранения, и последующего тестирования. Данные из модуля в параллельном потоке читаются в mailbox read_data. Действие происходит в таске check_data, где проверяются выходные данные data_o, в будущем верификация происходит по сравнению генерированных и полученных данных.

Сравнение происходит в compare_date, когда пройдет TEST_CNT итераций.

При первом случае несоответствия переданных и полученных данных, программа остановится. (можно изменять есть включить DEBUG)

### data
#### hand-made
| WIDTH | Slow 1100mV 85C | Slow 1100mV 0C | ALMs/Registers |
| ----- | --------------- | -------------- | -------------- |
| 4     | 288.27          | 304.32         | 8, 21          | 


## install

```
git clone https://github.com/t1msi/fpga_lab_1.git
cd fpga_lab_1/additional_lab/a_3_delay_line/tb/
vsim&

do make.tcl
```