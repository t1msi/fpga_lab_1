
# priority_encoder

## task
Модуль должен во входном N-битном числе найти самую правую и самую левую единицу и оставить только ее.
На входе → Крайняя левая единица; Крайняя правая единица

## desc

| Параметр | Комментарий        | 
| -------- | ------------------ |
| WIDTH    | Разрядность данных |

| Имя сигнала  | Напр-е | Разрядность | Комментарий                                            |
| ------------ | ------ | ----------- |:------------------------------------------------------ |
| clk_i        | input  | 1           | Тактовый сигнал.                                       |
| srst_i       | input  | 1           | Синхронный сброс.                                      |
| data_i       | input  | WIDTH       | Входные данные.                                        |
| data_val_i   | input  | 1           | Сигнал валидности входных данных.                      |
| data_left_o  | output | WIDTH       | Выходная крайняя левая единица.                        |
| data_right_o | output | WIDTH       | Выходная крайняя правая единица.                       |
| data_val_o   | output | 1           | Подтверждает валидность data_right_o и<br>data_left_o. |

### alg
- 3 последовательных блока, для контроля :
    - итератора mod_counter
    - бита валидности data_val_o
    - обработанных данных data_left_o и data_right_o (с помощью вычисления max и min, соответственно)
- Остановка итератора происходит за счет следующих условий: либо срабатывание reset, либо равенство итератора с количеством бит входных данных, либо data_i равен 0.
- Передача во внешнюю среду происходит за 1 такт, после этого будут набираться новые значения
- Запись идет за счет вычисления max и min, то есть перебирается каждый бит data_i за O(n)
- Управление происходит в конечном автомате сигналами IDLE_S, PROC_S, SEND_S. Состояние меняется каждый такт, из-за этого после обработки сигнала SEND_S держится 1 такт, и только после "полной отправки" внешний модуль может подавать положительный data_val_i (в tb.sv специально после ожидания data_val_o от модуля кодировщика добавляется repeat(pause + 1) @(posedge clk) )

### test
В скрипте для ModelSim вызываются 2 собственные функции do_compile start_sim

В начале testbench происходит первичная инициализация, до момента когда rst_done станет равен 1.

Отправка проводится за счет генерации входной последовтельности в таске gen_data и передачи в data_i, целиком WIDTH бит. В цикле таска send_data меняется значение data_i и data_val_i, причем посылка идет целиком за 1 такт из-за валидности равной 1. Между вызовами send_data может проходить либо случайное количество циклов, либо без задержек (опция burst, по умолчанию. Для переключения передать в fifo_wr третий параметр 1)

После отправки целого числа, происходит запись в mailbox sended_data для сохранения, и последующего тестирования. Обработанные модулем данные в параллельном потоке читаются в mailbox read_data, запись происходит в момент, когда модуль дал сигнал о получении "посылки" с помощью бита валидности data_val_o. Сравнение происходит в compare_date, когда пройдет TEST_CNT + 4 итераций (добавляются corner cases).

При первого случаи несоответствия переданных и полученных данных, программа остановится.

## install

```
git clone https://github.com/t1msi/fpga_lab_1.git
cd fpga_lab_1/1_3_priority_encoder/tb/
vsim&

do make.tcl
```

## ref
- https://www.youtube.com/playlist?list=PLOiK7Vmp7kf-YmjuuJKvDvmJdxKs826kx
- https://github.com/stcmtk/fpga-webinar-2020
- https://github.com/johan92/fpga-for-beginners
- https://habr.com/en/articles/281525/
- [Работа с битами](https://youtu.be/ZizuOhdl5oA?si=Yz_HniadGCZexxZX)